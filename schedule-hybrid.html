<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Event Schedule — Hybrid (Grouped Days with Lanes)</title>
  <!--
    Schedule grid semantics and visual rules
    - Row granularity: Each body row represents a 15-minute time block. The Time label is the START of that block.
      Example: the row labeled "0600" covers 0600–0615.
    - Labels: Only :00 and :30 rows show a time label; :15 and :45 rows are unlabeled (still present for layout).
    - Horizontal grid lines: Drawn at the START of :00 and :30 rows using TOP borders; :00 rows are thicker (2px).
      :15 and :45 rows have transparent top/bottom so no horizontal line appears.
    - Late block: 2200–2300 renders as four 15-minute rows with the same rules.
    - Events:
        * Full-block cells (td.block with rowspan > 1) color the entire cell and have a 1px black border around the cell.
          The inner .event inside a block cell has no border (border is on the cell).
        * Non-block events render as colored ".event" pills with a 1px black border.
        * 15-minute events (rowSpan === 1) get class ".short" for a smaller, tighter label.
    - Implementation notes:
        * tr.quarter-hour marks :15 and :45 rows used to suppress horizontal lines.
        * tr.hour-mark marks exact-hour rows (:00) to render a thicker top border.
        * Grid lines are border-top on non-quarter rows; the time label sits above the line.
  -->
  <style>
    :root {
      --border: #1d3557;
      --grid: #324a6b33;
      --header-bg: #eef3f9;
      --time-bg: #f8fafc;
      --text: #0f172a;
      --row-h: 28px; /* consistent row height */

      /* Lane header colors inspired by the reference image */
      --lane-ech: #d78bdc;          /* purple */
      --lane-planners: #f29d4b;     /* orange */
      --lane-bwatch: #79c94e;       /* green */
      --lane-adj: #1fa5da;          /* blue */
    }

    html, body { height: 100%; }
    body {
      margin: 0; 
      font-family: "Segoe UI", Tahoma, Arial, sans-serif; 
      color: var(--text);
      background: white;
    }

    header.classification {
      text-align: center;
      padding: 6px 8px;
      font-weight: 700;
      letter-spacing: 0.5px;
      color: #2e7d32;
    }

    .wrap {
      padding: 12px 16px 24px;
      overflow: auto;
    }

    h1 { font-size: 18px; margin: 0 0 12px; }
    .subtitle { color: #334155; font-size: 12px; margin-bottom: 10px; }

    table.schedule {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed; /* keeps lanes aligned */
      border: 1px solid var(--border);
    }

    caption { 
      caption-side: top; 
      font-weight: 600; 
      text-align: left; 
      padding: 6px 4px; 
    }

    col.time-col { width: 84px; }

    thead th, tbody td {
      border: 1px solid var(--border);
    }

    thead th {
      background: var(--header-bg);
      font-size: 12px;
      padding: 6px 8px;
      text-align: center;
      position: sticky; /* sticky header */
      top: 0;
      z-index: 3;
    }

    thead th.group {
      font-weight: 800;
      border-bottom-width: 2px;
    }

    thead th.subhead { font-weight: 600; }

    thead th.lane-ech { background: color-mix(in lab, var(--lane-ech) 65%, white); }
    thead th.lane-planners { background: color-mix(in lab, var(--lane-planners) 65%, white); }
    thead th.lane-bwatch { background: color-mix(in lab, var(--lane-bwatch) 65%, white); }
    thead th.lane-adj { background: color-mix(in lab, var(--lane-adj) 65%, white); color: #09263a; }

    /* Sticky first column */
    th.time, td.time {
      position: sticky;
      left: 0;
      z-index: 2;
      background: var(--time-bg);
      text-align: right;
      font-feature-settings: "tnum" 1, "lnum" 1;
      white-space: nowrap;
    }

    th.time { top: 0; z-index: 4; }

    tbody td {
      padding: 6px 8px;
      font-size: 12px;
      vertical-align: top;
    }

    /* Consistent row height across the grid (rowspan multiples stack naturally) */
    tbody tr { height: var(--row-h); }

    tbody tr:nth-child(even) td:not(.time) {
      background-color: #fbfdff;
    }

    /* When a cell represents a multi-row event, tint the full background */
    tbody td.block {
      font-weight: 600;
      vertical-align: middle;
      text-align: center;
      /* Reduce padding so single 15-min rows don't expand */
      padding: 2px 4px;
    }
    tbody td.block.tan {
      background-color: #f0d19b; /* tan */
      color: #1d1d1d;
    }
    tbody td.block.adj {
      background-color: var(--lane-adj); /* blue */
      color: #ffffff;
    }
    tbody td.block.ech { background-color: var(--lane-ech); }
    tbody td.block.planners { background-color: var(--lane-planners); }
    tbody td.block.bwatch { background-color: var(--lane-bwatch); }
    /* Make the inner pill transparent when used inside a block-filled cell */
    tbody td.block .event {
      background: transparent;
      padding: 2px 2px;
      /* Avoid forcing row growth; inherit base .event font-size */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Special late block row (2200–2300) */
    tr.late-block td, tr.late-block th {
      border-top: 4px solid #111;
    }

    /* Quarter-hour rows (no time labels) */
    /* Keep the sticky time column's right divider, but remove horizontal lines on quarter rows */
    tr.quarter-hour td.time { border-right: 1px solid var(--border); }
    tr.quarter-hour td { border-top-color: transparent; border-bottom-color: transparent; }
    /* Draw grid line at :00 and :30 by using TOP border on non-quarter rows (lines at the start of each block) */
    tbody tr:not(.quarter-hour) td { border-top: 1px solid #000; border-bottom-color: transparent; }
    /* Thicker lines on exact hours */
    tbody tr.hour-mark td { border-top-width: 2px !important; border-top-color: #000 !important; }
    /* Preserve the thick separator for the late block */
    tr.late-block td, tr.late-block th { border-top: 4px solid #111; }

    /* Compact helpers for content blocks inside cells */
    .event {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
      font-weight: 600;
      font-size: clamp(10px, 2.5vw, 16px);
      width: 100%;
      box-sizing: border-box;
      text-align: center;
      border: 2px solid #000; /* thick border around non-block event pill */
    }
    /* Full-block cells: draw a thick inner border independent of table border-collapsing */
    tbody td.block { position: relative; }
    tbody td.block .event { border: none; }
    tbody td.block::after {
      content: "";
      position: absolute;
      inset: 0; /* cover entire cell */
      border: 2px solid #000;
      pointer-events: none;
      border-radius: 0;
      box-sizing: border-box;
    }
    /* Smart border suppression for block overlays
       - Hide top border when event starts on an exact hour (:00) or when marked as no-top due to adjacency
       - Hide bottom border when event ends on an exact hour (:00) or when marked as no-bottom due to adjacency */
    tbody td.block.starts-hour::after,
    tbody td.block.no-top::after { border-top: 0; }
    tbody td.block.ends-hour::after,
    tbody td.block.no-bottom::after { border-bottom: 0; }
    /* Smaller label for 15-minute events */
    .event.short { font-size: 85%; padding: 1px 4px; }
    .event.ech { background: var(--lane-ech); }
    .event.planners { background: var(--lane-planners); }
    .event.bwatch { background: var(--lane-bwatch); }
    .event.adj { background: var(--lane-adj); color: white; }
    .event.tan { background: #f0d19b; color: #2b2b2b; }

    /* Print tweaks */
    @media print {
      .wrap { padding: 0; }
      header.classification { padding: 2px 0; }
      thead th { position: sticky; top: 0; }
    }
  </style>
</head>
<body>
  <header class="classification">UNCLASSIFIED</header>
  <div class="wrap">
    <h1>Weekly Event Schedule</h1>
  <div class="subtitle">Hybrid layout: grouped days with varying lane counts; 15-minute intervals 0600–1700, plus 2200–2300.</div>

    <table class="schedule" aria-describedby="table-desc">
      <caption id="table-desc">Time down the left; grouped day headers across the top. Total lanes: 11.</caption>
      <colgroup>
        <col class="time-col" />
        <!-- 11 lanes (content columns) -->
        <col span="11" />
      </colgroup>
      <thead>
        <tr>
          <th class="time" rowspan="2" scope="col">Time</th>
          <!-- Day groups with specified colspans: 1, 2, 2, 4, 2 -->
          <th class="group" scope="colgroup" colspan="1">15 Oct (Wed)</th>
          <th class="group" scope="colgroup" colspan="2">16 Oct (Thu)</th>
          <th class="group" scope="colgroup" colspan="2">17 Oct (Fri)</th>
          <th class="group" scope="colgroup" colspan="4">Game Days (Players &amp; Adjudicators)<br/>18–23 Oct (Excl Sun)</th>
          <th class="group" scope="colgroup" colspan="2">24 Oct (Fri)</th>
        </tr>
        <tr>
          <!-- 11 subordinate lane headers -->
          <th class="subhead" scope="col">Events</th>

          <th class="subhead" scope="col">Lane 1</th>
          <th class="subhead" scope="col">Lane 2</th>

          <th class="subhead" scope="col">Lane 1</th>
          <th class="subhead" scope="col">Lane 2</th>

          <th class="subhead lane-ech" scope="col">Ech 2 &amp; 3</th>
          <th class="subhead lane-planners" scope="col">Planners (Main/TA)</th>
          <th class="subhead lane-bwatch" scope="col">Battle Watch</th>
          <th class="subhead lane-adj" scope="col">Adjudication</th>

          <th class="subhead" scope="col">Players</th>
          <th class="subhead" scope="col">DVs</th>
        </tr>
      </thead>
      <tbody id="schedule-body">
        <!-- Populated by JS -->
      </tbody>
    </table>

    <p style="margin-top:12px; font-size:12px; color:#475569;">
      Tip: Add event pills inside cells using <code>&lt;span class="event ech|planners|bwatch|adj"&gt;Label&lt;/span&gt;</code>.
    </p>
  </div>

  <script>
    // CSV parsing functionality
    async function parseCSV() {
      try {
        const response = await fetch('schedule.csv');
        const csvText = await response.text();
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',');

        return lines.slice(1).map(line => {
          const values = line.split(',');
          const event = {};
          headers.forEach((header, index) => {
            event[header.trim()] = values[index] ? values[index].trim() : '';
          });
          return event;
        }).filter(event => event.day); // Filter out empty rows
      } catch (error) {
        console.error('Error loading CSV:', error);
        return [];
      }
    }

    // Location to color mapping
    function getColorClass(location) {
      const locationMap = {
        'Individual': 'tan',
        'C-306/7': 'adj',
        'C-109': 'ech',
        'C-109 + VTC': 'ech',
        'C-109 / W-129A': 'ech',
        'C-109 / Virtual': 'ech',
        'Cells': 'planners',
        'E-100': 'bwatch',
        'MLH': 'tan',
        'Sims': 'bwatch',
        'Sims Lobby': 'bwatch'
      };
      return locationMap[location] || 'tan';
    }

    (function buildRows() {
      const tbody = document.getElementById('schedule-body');

      // Configurable time window
      const startMinutes = 6 * 60;   // 0600
  const endMinutes = 17 * 60;    // 1700 for span calculations
  const lastRowTime = endMinutes - 15;   // last starting slot at 16:45 covers to 17:00
      const step = 15;               // minutes

      const lanes = 11;              // per requirements (excludes Time column)

      function fmt(num) { return String(num).padStart(2, '0'); }
      function labelFromMinutes(total) {
        const h = Math.floor(total / 60);
        const m = total % 60;
        return `${fmt(h)}${fmt(m)}`; // e.g., 0615
      }

      // Generate rows from 0600 to 1700
      for (let t = startMinutes; t <= lastRowTime; t += step) {
        const tr = document.createElement('tr');
        const timeCell = document.createElement('td');
        timeCell.className = 'time';

        // Only show labels on half-hours and hours
        const minutes = t % 60;
        if (minutes === 0 || minutes === 30) {
          timeCell.textContent = labelFromMinutes(t);
        } else {
          timeCell.textContent = '';
          tr.classList.add('quarter-hour');
        }
        if (minutes === 0) tr.classList.add('hour-mark');
        tr.appendChild(timeCell);

        for (let i = 0; i < lanes; i++) {
          const td = document.createElement('td');
          td.setAttribute('data-lane', String(i + 1));
          td.setAttribute('data-time', t); // Store time for event mapping
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      // Add rows for 2200-2300 (22:00 to 23:00) with 15-minute increments
      for (let t = 22 * 60; t <= 23 * 60 - 15; t += step) {
        const tr = document.createElement('tr');
        if (t === 22 * 60) tr.className = 'late-block'; // Dark separator for first row

        const timeCell = document.createElement('td');
        timeCell.className = 'time';

        // Only show labels on half-hours and hours
        const minutes = t % 60;
        if (minutes === 0 || minutes === 30) {
          timeCell.textContent = labelFromMinutes(t);
        } else {
          timeCell.textContent = '';
          tr.classList.add('quarter-hour');
        }
        if (minutes === 0) tr.classList.add('hour-mark');
        tr.appendChild(timeCell);

        for (let i = 0; i < lanes; i++) {
          const td = document.createElement('td');
          td.setAttribute('data-lane', String(i + 1));
          td.setAttribute('data-time', t);
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      // --- Helper functions to add multi-row events ---
      function parseTime(hhmm) {
        // Accepts '07:00' format from CSV
        const parts = String(hhmm).split(':');
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10) || 0;
        return h * 60 + m;
      }

      function addEventFromCSV(event) {
        const lane = parseInt(event.lane_num);
        const startTime = parseTime(event.start_time);
        const endTime = parseTime(event.end_time);
        const label = event.title;
        const cssClass = getColorClass(event.location);

        if (endTime <= startTime) return;

        // Handle events that span into late hours (22:00+)
        let adjustedEndTime = endTime;
        let adjustedStartTime = startTime;

        // Find the appropriate row based on time
        let targetRow = null;
        let startRowIndex = -1;

        // Look for row with matching time
        for (let i = 0; i < tbody.rows.length; i++) {
          const row = tbody.rows[i];
          const cell = row.querySelector('td[data-time]');
          if (cell) {
            const rowTime = parseInt(cell.getAttribute('data-time'));
            if (rowTime === adjustedStartTime) {
              targetRow = row;
              startRowIndex = i;
              break;
            }
          }
        }

        if (!targetRow) return;

        const cell = targetRow.querySelector(`td[data-lane='${lane}']`);
        if (!cell) return;

  // Calculate span in 15-minute increments
  const spanRows = Math.round((adjustedEndTime - adjustedStartTime) / step);

        // Fill content and set rowspan; color the entire cell background
        const pill = document.createElement('span');
        pill.className = 'event';
        if (spanRows === 1) {
          pill.classList.add('short');
        }
        pill.textContent = label;
        cell.innerHTML = '';
        cell.appendChild(pill);
        cell.rowSpan = spanRows;
        cell.classList.add('block');
        if (cssClass) cell.classList.add(cssClass);

        // Attach metadata for adjacency logic and hour seam suppression
        cell.setAttribute('data-start', String(adjustedStartTime));
        cell.setAttribute('data-end', String(adjustedEndTime));
        if (adjustedStartTime % 60 === 0) {
          cell.classList.add('starts-hour');
        }
        if (adjustedEndTime % 60 === 0) {
          cell.classList.add('ends-hour');
        }

        // Remove the covered cells in subsequent rows for this lane
        for (let r = startRowIndex + 1; r < startRowIndex + spanRows; r++) {
          const row = tbody.rows[r];
          if (!row) break;
          const covered = row.querySelector(`td[data-lane='${lane}']`);
          if (covered) covered.remove();
        }
      }

      // Load and populate events from CSV
      async function populateFromCSV() {
        const events = await parseCSV();
        events.forEach(event => {
          if (event.lane_num && event.start_time && event.end_time && event.title) {
            addEventFromCSV(event);
          }
        });
      }

      // After all events are placed, mark vertical adjacency (back-to-back events in the same lane)
      function markVerticalAdjacency() {
        for (let laneIdx = 1; laneIdx <= lanes; laneIdx++) {
          const blocks = Array.from(document.querySelectorAll(`td.block[data-lane='${laneIdx}']`));
          if (blocks.length < 2) continue;
          // Sort by start time to ensure chronological order
          blocks.sort((a, b) => parseInt(a.getAttribute('data-start') || '0') - parseInt(b.getAttribute('data-start') || '0'));
          for (let i = 0; i < blocks.length - 1; i++) {
            const a = blocks[i];
            const b = blocks[i + 1];
            const aEnd = parseInt(a.getAttribute('data-end') || '0');
            const bStart = parseInt(b.getAttribute('data-start') || '0');
            if (aEnd === bStart) {
              // Suppress the interior seam: keep bottom on A unless it's an hour seam (handled by ends-hour), remove top on B
              b.classList.add('no-top');
            }
          }
        }
      }

      // Populate the schedule
      populateFromCSV().then(() => {
        markVerticalAdjacency();
      });
    })();
  </script>
</body>
</html>
